<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="O]rHd$6W,,K4d7Bkc!$b" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="v]i]@-)Vo)SAJ_Qh5rW*" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Vector2 {" line1="    public x: number;" line2="    public y: number;" line3="    constructor(x: number, y: number) {" line4="        this.x = x;" line5="        this.y = y;" line6="    }" line7="    static distance(start: Vector2, end: Vector2) {" line8="        let xDist = end.x - start.x;" line9="        let yDist = end.y - start.y;" line10="        return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));" line11="    }" line12="}" numlines="13"></mutation><next><block type="typescript_statement" id="aj{9fQ)6/Lg}@D:c+2Vm" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Node {" line1="    position: Vector2;" line2="    parent: Node;" line3="    G: int16;" line4="    constructor(position: Vector2, parent: Node) {" line5="        this.position = position;" line6="        this.parent = parent;" line7="        if (this.parent) {" line8="            this.G = this.parent.G + 1;" line9="        }" line10="    }" line11="}" numlines="12"></mutation><next><block type="typescript_statement" id="#lXh0$!;`s]T6gGLM7hb" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class NodeList {" line1="    list: Array&lt;Node&gt;;" line2="    constructor() {" line3="        this.list = [];" line4="    }" line5="    add(node: Node) {" line6="        this.list.push(node);" line7="    }" line8="    size() {" line9="        return this.list.length;" line10="    }" line11="    get(index: number) {" line12="        return this.list[index];" line13="    }" line14="    containsPosition(node: Vector2) {" line15="        for (let i = 0; i &lt; this.size(); i++) {" line16="            if (this.list[i].position.x == node.x &amp;&amp; this.list[i].position.y == node.y) {" line17="                return this.list[i];" line18="            }" line19="        }" line20="        return null;" line21="    }" line22="    removeElement(node: Node) {" line23="        let index = this.list.indexOf(node);" line24="        if (index != -1) {" line25="            this.list.removeAt(index);" line26="            return true;" line27="        }" line28="        return false;" line29="    }" line30="}" numlines="31"></mutation><next><block type="typescript_statement" id="B$WNan,L+W]-2^[8TcF~" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class PathFinder {" line1="    origin: Node;" line2="    sprite: Sprite;" line3="    followTarget: Sprite;" line4="" line5="    map: tiles.TileMapData;" line6="    openList: NodeList;" line7="    closedList: NodeList;" line8="" line9="    constructor(map: tiles.TileMapData, followtargetIMG: Image) {" line10="        this.map = map;" line11="        this.followTarget = sprites.create(followtargetIMG);" line12="    }" line13="" line14="    attachSprite(sprite: Sprite) {" line15="        this.sprite = sprite;" line16="        this.followTarget.setPosition(this.sprite.x, this.sprite.y);" line17="        this.sprite.follow(this.followTarget);" line18="    }" line19="" line20="    updatePathfinding(target: Sprite) {" line21="        this.origin = new Node(new Vector2(target.tilemapLocation().col, target.tilemapLocation().row), null);" line22="        this.origin.G = 0;" line23="        if (Vector2.distance(new Vector2(this.followTarget.x, this.followTarget.y), new Vector2(this.sprite.x, this.sprite.y)) &lt; 5) {" line24="            let path = this.findPath(new Vector2(target.tilemapLocation().col, target.tilemapLocation().row));" line25="            let next = path[path.length - 1];" line26="            console.log(next.x + &quot; &quot; + next.y);" line27="            tiles.placeOnTile(this.followTarget, tiles.getTileLocation(next.x, next.y));" line28="        }" line29="    }" line30="" line31="    findPath(goal: Vector2) {" line32="        let showProcess = false;     //show Process" line33="        let width = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns);" line34="        let height = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows);" line35="        this.openList = new NodeList();" line36="        this.closedList = new NodeList();" line37="        this.openList.add(this.origin);" line38="        let offsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];" line39="        while (this.openList.size() &gt; 0) {" line40="            let currentSquare: Node;" line41="            let lowestF = Infinity;" line42="            for (let j = 0; j &lt; this.openList.size(); j++) {" line43="                let F = this.calculateF(this.openList.get(j), goal);" line44="                if (F &lt; lowestF) {" line45="                    lowestF = F;" line46="                    currentSquare = this.openList.get(j);" line47="                }" line48="            }" line49="            this.openList.removeElement(currentSquare);" line50="            this.closedList.add(currentSquare);" line51="            for (let k = 0; k &lt; offsets.length; k++) {" line52="                let nodePos = new Vector2(currentSquare.position.x + offsets[k][0], currentSquare.position.y + offsets[k][1]);" line53="                let closed = this.closedList.containsPosition(nodePos);" line54="                if (this.getWalkable(nodePos) &amp;&amp; !closed) {" line55="                    let position = this.openList.containsPosition(nodePos);" line56="                    if (position) {" line57="                        if (currentSquare.G + 1 &lt; position.G) {" line58="                            position.parent = currentSquare;" line59="                            position.G = currentSquare.G + 1;" line60="                        }" line61="                    } else {" line62="                        this.openList.add(new Node(nodePos, currentSquare));" line63="                    }" line64="                }" line65="            }" line66="            let node = this.closedList.containsPosition(goal);" line67="            if (node != null) {" line68="                let path2 = [];" line69="                while (node.parent) {" line70="                    path2.push(node.position);" line71="                    node = node.parent;" line72="                }" line73="                return path2;" line74="            }" line75="        }" line76="        return null;" line77="    }" line78="" line79="    calculateF(node: Node, goal: Vector2) {" line80="        let G = node.G;" line81="        let H = Vector2.distance(node.position, goal);" line82="        return G + H;" line83="    }" line84="" line85="    getWalkable(position: Vector2) {" line86="        if (this.closedList.containsPosition(position)) {" line87="            return false;" line88="        }" line89="        if (this.map.isWall(position.x, position.y)) {" line90="            return false;" line91="        }" line92="        if (position.x &lt; 0 || position.x &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns)) {" line93="            return false;" line94="        }" line95="        if (position.y &lt; 0 || position.y &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows)) {" line96="            return false;" line97="        }" line98="" line99="        return true;" line100="    }" line101="}" numlines="102"></mutation></block></next></block></next></block></next></block></statement></block></xml>