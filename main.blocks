<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="(e5*hm{O2M`#Nczp/1AI" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="t:dROy5KG^?M)J9o:oUF" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Vector2 {" line1="    public x: number;" line2="    public y: number;" line3="    constructor(x: number, y: number) {" line4="        this.x = x;" line5="        this.y = y;" line6="    }" line7="    static distance(start: Vector2, end: Vector2) {" line8="        let xDist = end.x - start.x;" line9="        let yDist = end.y - start.y;" line10="        return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));" line11="    }" line12="}" numlines="13"></mutation><next><block type="typescript_statement" id="VD|i5#5P@z9;pQ`E5BnD" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Node {" line1="    position: Vector2;" line2="    parent: Node;" line3="    G: int16;" line4="    constructor(position: Vector2, parent: Node) {" line5="        this.position = position;" line6="        this.parent = parent;" line7="        if (this.parent) {" line8="            this.G = this.parent.G + 1;" line9="        }" line10="    }" line11="}" numlines="12"></mutation><next><block type="typescript_statement" id="inD5;[pZRXyH6G#2@?e7" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class NodeList {" line1="    list: Array&lt;Node&gt;;" line2="    constructor() {" line3="        this.list = [];" line4="    }" line5="    add(node: Node) {" line6="        this.list.push(node);" line7="    }" line8="    size() {" line9="        return this.list.length;" line10="    }" line11="    get(index: number) {" line12="        return this.list[index];" line13="    }" line14="    containsPosition(node: Vector2) {" line15="        for (let i = 0; i &lt; this.size(); i++) {" line16="            if (this.list[i].position.x == node.x &amp;&amp; this.list[i].position.y == node.y) {" line17="                return this.list[i];" line18="            }" line19="        }" line20="        return null;" line21="    }" line22="    removeElement(node: Node) {" line23="        let index = this.list.indexOf(node);" line24="        if (index != -1) {" line25="            this.list.removeAt(index);" line26="            return true;" line27="        }" line28="        return false;" line29="    }" line30="}" numlines="31"></mutation><next><block type="typescript_statement" id="?G)xE91(pfD/-O*I[I??" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class PathFinder {" line1="    origin: Node;" line2="    sprite: Sprite;" line3="    followTarget: Sprite;" line4="" line5="    map: tiles.TileMapData;" line6="    openList: NodeList;" line7="    closedList: NodeList;" line8="" line9="    constructor(map: tiles.TileMapData) {" line10="        this.map = map;" line11="    }" line12="" line13="    attachSprite(sprite: Sprite) {" line14="        this.sprite = sprite;" line15="    }" line16="" line17="    updatePathfinding(target: Sprite) {" line18="        this.origin = new Node(new Vector2(this.sprite.x, this.sprite.y), null);" line19="        this.origin.G = 0;" line20="        if (Vector2.distance(new Vector2(this.followTarget.x, this.followTarget.y), new Vector2(this.sprite.x, this.sprite.y)) &lt; 5) {" line21="            let path = this.findPath(new Vector2(target.tilemapLocation().col, target.tilemapLocation().row));" line22="            let next = path[path.length - 1];" line23="            this.followTarget.setPosition(next.x, next.y);" line24="        }" line25="    }" line26="" line27="    findPath(goal: Vector2) {" line28="        let showProcess = false;     //show Process" line29="        let width = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns);" line30="        let height = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows);" line31="        this.openList = new NodeList();" line32="        this.closedList = new NodeList();" line33="        this.openList.add(this.origin);" line34="        let offsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];" line35="        while (this.openList.size() &gt; 0) {" line36="            let currentSquare: Node;" line37="            let lowestF = Infinity;" line38="            for (let j = 0; j &lt; this.openList.size(); j++) {" line39="                let F = this.calculateF(this.openList.get(j), goal);" line40="                if (F &lt; lowestF) {" line41="                    lowestF = F;" line42="                    currentSquare = this.openList.get(j);" line43="                }" line44="            }" line45="            this.openList.removeElement(currentSquare);" line46="            this.closedList.add(currentSquare);" line47="            for (let k = 0; k &lt; offsets.length; k++) {" line48="                let nodePos = new Vector2(currentSquare.position.x + offsets[k][0], currentSquare.position.y + offsets[k][1]);" line49="                let closed = this.closedList.containsPosition(nodePos);" line50="                if (this.getWalkable(nodePos) &amp;&amp; !closed) {" line51="                    let position = this.openList.containsPosition(nodePos);" line52="                    if (position) {" line53="                        if (currentSquare.G + 1 &lt; position.G) {" line54="                            position.parent = currentSquare;" line55="                            position.G = currentSquare.G + 1;" line56="                        }" line57="                    } else {" line58="                        this.openList.add(new Node(nodePos, currentSquare));" line59="                    }" line60="                }" line61="            }" line62="            let node = this.closedList.containsPosition(goal);" line63="            if (node != null) {" line64="                let path2 = [];" line65="                while (node.parent) {" line66="                    path2.push(node.position);" line67="                    node = node.parent;" line68="                }" line69="                return path2;" line70="            }" line71="        }" line72="        return null;" line73="    }" line74="" line75="    calculateF(node: Node, goal: Vector2) {" line76="        let G = node.G;" line77="        let H = Vector2.distance(node.position, goal);" line78="        return G + H;" line79="    }" line80="" line81="    getWalkable(position: Vector2) {" line82="        if (this.closedList.containsPosition(position)) {" line83="            return false;" line84="        }" line85="        if (this.map.isWall(position.x, position.y)) {" line86="            return false;" line87="        }" line88="        if (position.x &lt; 0 || position.x &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns)) {" line89="            return false;" line90="        }" line91="        if (position.y &lt; 0 || position.y &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows)) {" line92="            return false;" line93="        }" line94="" line95="        return true;" line96="    }" line97="}" numlines="98"></mutation></block></next></block></next></block></next></block></statement></block></xml>